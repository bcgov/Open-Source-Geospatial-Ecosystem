<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUP Overview</title>
</head>
<body>
    <div id="overview"></div>
    



    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
    <script src="https://unpkg.com/leaflet-wfst@2.0.1-beta.27/dist/leaflet-wfst.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
    <script src="/plugins/leaflet.filelayer.js"></script>


    <script>
        // Initialize the map
        var map = L.map('overview').setView([55.781113, -128.867888], 7);

        // Base layer setup
        var CartoDB_Positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        L.tileLayer('https://maps.gov.bc.ca/arcgis/rest/services/province/web_mercator_cache/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; <a href="https://data.gov.bc.ca/">BC Government</a>',
            maxZoom: 20,
            errorTileUrl: 'path-to-error-image.png' 
        }).addTo(map);
        
        // WFS data source URL
        const SERVICE_URL = "http://localhost:5000/wfs/";

        // A simple GeoJSON layer example for AOI (Area of Interest)
        var lup_aoi= 
        {
            "type": "FeatureCollection",
            "name": "aoi",
            "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::4326" } },
            "features": [
            { "type": "Feature", "properties": { "OBJECTID": 3.0, "SHAPE_Leng": 908959.60400000215, "SHAPE_Area": 51484492817.909615, "X_Max": null, "X_Min": null, "Y_Max": null, "Y_Min": null, "centerx": null, "centery": null, "Lat_Max": -127.12066348938077, "Lat_Min": -130.70713817004415, "Lon_Max": 56.880992958850584, "Lon_Min": 54.658316969110963 }, "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ -128.877519335263372, 56.854459870751043 ], [ -128.47103084514157, 56.862845226243849 ], [ -127.182976424146929, 56.880987675036366 ], [ -127.120645609878679, 54.734177239127789 ], [ -130.459733007391407, 54.658312163230242 ], [ -130.707118882745391, 56.800867888548048 ], [ -128.877519335263372, 56.854459870751043 ] ] ] ] } }
            ]
        };
        // pull json from same directory
        let jsonData = [];

        fetch('/static/layers.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                jsonData = data;
                console.log('JSON Data Loaded:', jsonData);
                createCheckboxes(document.getElementById('checkbox-container'));
            })
            .catch(error => {
                console.error('Error loading JSON file:', error);
            });

        L.geoJSON(lup_aoi, {
            style: { fillColor: 'transparent', color: 'black', weight: 4 }
        }).addTo(map);

        const checkboxContainer = document.getElementById('checkbox-container');

        // Function to create checkboxes dynamically based on jsonData
        function createCheckboxes(container) {
            jsonData.forEach((layer, index) => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" onclick="layerToggleWFS(this, ${index})" /> ${layer.name}`;
                checkboxContainer.appendChild(label);
                checkboxContainer.appendChild(document.createElement('br'));
            });
        }

        // Call the function to create checkboxes
        createCheckboxes(checkboxContainer);

        /*
        function toggleCheckboxContainer() {
            const checkboxContent = document.getElementById('checkboxContent');
            const toggleButton = document.getElementById('toggleCheckboxContainer');
        
            if (checkboxContent.style.display === "none") {
                checkboxContent.style.display = "block";
                toggleButton.textContent = "▲"; // Upward arrow to indicate expanded state
            } else {
                checkboxContent.style.display = "none";
                toggleButton.textContent = "▼"; // Downward arrow to indicate minimized state
            }
        }
        */

        // add file layer upload to map
        var control = L.Control.fileLayerLoad({
            layer: L.geoJSON,
            layerOptions: {style: {color: getRandomColor()}},
            addToMap: true,
            fileSizeLimit: 1024,
            formats: [
                '.kml',
                '.geojson'
            ]
        }).addTo(map);

        // Array to keep track of uploaded layers
        let uploadedLayers = [];

        function createCheckboxForAddedLayer(layer, fileName,) {
            const label = document.createElement("label");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = true;

            // Checkbox click event to add or remove the layer from the map
            checkbox.onclick = () => {
                checkbox.checked ? map.addLayer(layer) : map.removeLayer(layer);
            };

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(" " + fileName));
            checkboxContainer.appendChild(label);
            checkboxContainer.appendChild(document.createElement("br"));
        }

        // Event handler for loaded files
        control.loader.on('data:loaded', function(event) {
            const layer = event.layer;
            uploadedLayers.push(layer);
        
            const fileName = event.filename || "Uploaded Layer " + uploadedLayers.length;
            const color = getRandomColor(); // Generate a color for the layer
        
            // Style the uploaded layer with the random color
            layer.setStyle({
                color: color,
                weight: 2
            });
        
            // Add the uploaded layer to the map
            map.addLayer(layer);
        
            // Create a checkbox for toggling the layer
            createCheckboxForAddedLayer(layer, fileName);
        
            // Add the uploaded layer to the legend
            updateLegend(fileName, color, 1, "add");
        });
        
        // Function to generate the WFS query URL
        function wfsQuery(dataset, query = null, fields = [], startIndex = 0, count = null ) {
            const SERVICE_URL = "http://localhost:5000/wfs";
        
            const params = new URLSearchParams({
            
                service: 'WFS',
                version: '2.0.0',
                request: 'GetFeature',
                typeName: `pub:${dataset}`,
                outputFormat: 'application/json',
                srsName: 'EPSG:4326',
                bbox: [54.94267775412879,-130.02081515748938, 56.60674270353342,-127.66422698319626, 'urn:ogc:def:crs:EPSG:4326'],
                sortBy: 'OBJECTID',
                limit: 1000000,
                offset: startIndex 
            });
        
            // Use INTERSECTS filter with a POLYGON if bbox is provided
        
            if (query) {
                params.delete('bbox');
                if (params.has('CQL_FILTER')) {
                    params.set('CQL_FILTER', `${params.get('CQL_FILTER')} AND ${query}`);
                } else {
                    params.set('CQL_FILTER', query);
                }
            }
        
            if (fields && fields.length > 0) {
                params.append('propertyName', fields.map(field => field.toUpperCase()).join(','));
            }
        
            if (count !== null) {
                params.append('count', count);
            }
        
            const url = `${SERVICE_URL}${params.toString()}`;
            console.log("WFS URL:", url);
            return url;
        }
        // store active layers as an object keyed by layer name
        var activeLayers = {};

        // Fetch the WFS data and add it as a GeoJSON layer
        async function loadWFSData(dataset, query, fields, popupFields, color) {
            const url = wfsQuery(dataset, query, fields);
        
            try {
                const response = await fetch(url);
                const data = await response.json();
                const geoJsonLayer = L.geoJSON(data, {
                    style: {
                        color: color, // Use the color specified in jsonData
                        weight: 2
                    },
                    onEachFeature: function(feature, layer) {
                        if (feature.properties) {
                            // Construct the popup content dynamically based on the popupFields
                            let popupContent = "";
                            popupFields.forEach(field => {
                                if (feature.properties[field]) {
                                    popupContent += `<strong>${field}:</strong> ${feature.properties[field]}<br>`;
                                }
                            });
                            layer.bindPopup(popupContent);
                        }
                    }
                }).addTo(map);
        
                activeLayers[dataset] = geoJsonLayer;
                return geoJsonLayer;
            } catch (error) {
                console.error("Error loading WFS data: ", error);
                return null;
            }
        }
        // Function to generate random color for styling layers
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        function updateLegend(layerName, color, transparency, action) {
            const legendContent = document.getElementById("legendContent");
        
            if (action === "add") {
                if (document.getElementById(`legend-${layerName}`)) return;
        
                const legendItem = document.createElement("div");
                legendItem.id = `legend-${layerName}`;
                legendItem.style.display = "flex";
                legendItem.style.alignItems = "center";
                legendItem.style.marginBottom = "5px";
        

                const colorPatch = document.createElement("span");
                colorPatch.style.width = "20px";
                colorPatch.style.height = "20px";
                colorPatch.style.backgroundColor = color;
                colorPatch.style.opacity = transparency;
                colorPatch.style.border = "1px solid #000";
                colorPatch.style.marginRight = "10px";
        
     
                const layerLabel = document.createElement("span");
                layerLabel.textContent = layerName;
        
  
                legendItem.appendChild(colorPatch);
                legendItem.appendChild(layerLabel);
        
       
                legendContent.appendChild(legendItem);
            } else if (action === "remove") {
    
                const legendItem = document.getElementById(`legend-${layerName}`);
                if (legendItem) {
                    legendContent.removeChild(legendItem);
                }
            }
        }
        
        // Toggle layer function updated to pass Popup and Color
        async function layerToggleWFS(checkbox, index) {
            const layerData = jsonData[index];
            const layerName= layerData.name
            const dataset = layerData.dataset;
            const query = layerData.query;
            const fields = JSON.parse(layerData.fields.replace(/'/g, '"'));
            const popupFields = JSON.parse(layerData.popup.replace(/'/g, '"')); // Convert to array
            const color = layerData.color; // Get the color
            const transparency = 0.5

            if (checkbox.checked) {
                if (!activeLayers[dataset]) {
                    const geoJsonLayer = await loadWFSData(dataset, query, fields, popupFields, color);
                    activeLayers[dataset] = geoJsonLayer;
                    updateLegend(layerName, color, transparency, "add");
                }
            } else {
                // Remove layer if unchecked
                if (activeLayers[dataset]) {
                    map.removeLayer(activeLayers[dataset]);
                    delete activeLayers[dataset];
                    updateLegend(layerName, color, transparency, "remove")
                }
            }
        }



    </script>
</body>
</html>