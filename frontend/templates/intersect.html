<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature Intersect</title>
    <link rel="stylesheet" href="../static/style.css">
</head>


<body>

<!-- Header Section -->

<div class="header">
    <img src="../static/BCID_H_rgb_rev.png" alt="British Columbia Logo" class="logo">
    <div class="title">BC Land Use Planning Tool</div>
    <div class="navbar">
        <ul>
            <li>
                Data & Mapping Tools 
            </li>
        </ul>
    </div>
</div>

<!-- Top Banner -->
<div class="banner">
    <div class="banner-title"><p>Intersect Tool</p></div>
</div>

    <h2>Upload a File to Intersect with Land Use Polygons</h2>
    <!-- Form for uploading data -->
    <form action="/intersect" method="POST" enctype="multipart/form-data">
        <input type="file" name="file" accept=".geojson,.shp,.kml,.gpx" required>
        <button type="submit">Upload and Intersect</button>
        {{uploaded_geojson}}
        <!-- {% if uploaded_geojson %}
            <script>
                const uploadedGeoJSON = {{ uploaded_geojson | tojson | safe }}   
            </script>
            <button type="button" onclick="addUploadedDataToMap(uploadedGeoJSON)">Show Data</button>
        {% endif %} -->
    </form>

    <!-- Map Section -->
    <div id="intersect">
            <!-- {{ leaflet_map | safe }} -->


        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
        <script src="https://unpkg.com/leaflet-wfst@2.0.1-beta.27/dist/leaflet-wfst.min.js"></script>

        <style>
            #intersect {
                width: 100%;
                height: 100vh;
                position: relative;
                margin: 0;
                padding: 0;
            }
            
            #layerContainer {
                position: fixed;
                top: 20px;
                right: 20px;
                width: 200px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

            #layerContent {
                display: block; /* Visible by default */
            }

            /* Style the toggle button */
            #toggleButton {
                background: none;
                border: none;
                font-size: 16px;
                cursor: pointer;
                float: right;
            }
        </style>

        <script>
            // Initialize the map
            var map = L.map('intersect').setView([55.781113, -128.867888], 7);

            var CartoDB_Positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);

            L.tileLayer('https://maps.gov.bc.ca/arcgis/rest/services/province/web_mercator_cache/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; <a href="https://data.gov.bc.ca/">BC Government</a>',
                maxZoom: 20,
                errorTileUrl: 'path-to-error-image.png'
            }).addTo(map);

            function addUploadedDataToMap(uploadedData) {
                console.log("Uploaded GeoJSON data:", uploadedData);

                if (uploadedData) {
                    try {
                        const uploadedLayer = L.geoJSON(uploadedData, {
                            style: {
                                color: "blue",
                                weight: 2,
                                fillOpacity: 0.4
                            },
                            onEachFeature: function (feature, layer) {
                                if (feature.properties) {
                                    layer.bindPopup(
                                        Object.entries(feature.properties)
                                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                                            .join("<br>")
                                    );
                                }
                            }
                        }).addTo(map);

                        map.fitBounds(uploadedLayer.getBounds());
                    } catch (error) {
                        console.error("Error adding GeoJSON to map:", error.message);
                    }
                } else {
                    console.error("No uploaded GeoJSON data found.");
                }
            }

            // WFS data source URL
            const SERVICE_URL = "http://localhost:5000/wfs/";



            var lup_aoi =
            {
                "type": "FeatureCollection",
                "name": "aoi",
                "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::4326" } },
                "features": [
                    { "type": "Feature", "properties": { "OBJECTID": 3.0, "SHAPE_Leng": 908959.60400000215, "SHAPE_Area": 51484492817.909615, "X_Max": null, "X_Min": null, "Y_Max": null, "Y_Min": null, "centerx": null, "centery": null, "Lat_Max": -127.12066348938077, "Lat_Min": -130.70713817004415, "Lon_Max": 56.880992958850584, "Lon_Min": 54.658316969110963 }, "geometry": { "type": "MultiPolygon", "coordinates": [[[[-128.877519335263372, 56.854459870751043], [-128.47103084514157, 56.862845226243849], [-127.182976424146929, 56.880987675036366], [-127.120645609878679, 54.734177239127789], [-130.459733007391407, 54.658312163230242], [-130.707118882745391, 56.800867888548048], [-128.877519335263372, 56.854459870751043]]]] } }
                ]
            };
            
            let jsonData = [];
            const maplayers = 'intersect';  // Change depending on map and layers.json
            
            fetch('/static/layers.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Check if the maplayers key exists in the JSON data
                    if (data.maps && data.maps[maplayers]) {
                        jsonData = data.maps[maplayers];
                        console.log(`Map Data for "${maplayers}":`, jsonData);
                        createCheckboxes(document.getElementById('checkbox-container'));
                    } else {
                        console.warn(`No data found for map layer "${maplayers}"`);
                    }
                })
                .catch(error => {
                    console.error('Error loading JSON file:', error);
                });
        

            L.geoJSON(lup_aoi, {
                style: { fillColor: 'transparent', color: 'black', weight: 4 }
            }).addTo(map);

            const checkboxContainer = document.getElementById('checkbox-container');

            // Function to create checkboxes dynamically based on jsonData
            function createCheckboxes(container) {
                jsonData.forEach((layer, index) => {
                    const label = document.createElement('label');
                    label.innerHTML = `<input type="checkbox" onclick="layerToggleWFS(this, ${index})" /> ${layer.name}`;
                    checkboxContainer.appendChild(label);
                    checkboxContainer.appendChild(document.createElement('br'));
                });
            }

            // Call the function to create checkboxes
            createCheckboxes(checkboxContainer);

            function toggleCheckboxContainer() {
                const checkboxContent = document.getElementById('checkboxContent');
                const toggleButton = document.getElementById('toggleCheckboxContainer');
            
                if (checkboxContent.style.display === "none") {
                    checkboxContent.style.display = "block";
                    toggleButton.textContent = "▲"; // Upward arrow to indicate expanded state
                } else {
                    checkboxContent.style.display = "none";
                    toggleButton.textContent = "▼"; // Downward arrow to indicate minimized state
                }
            }

            // Array to keep track of uploaded layers
            let uploadedLayers = [];

            function createCheckboxForAddedLayer(layer, fileName,) {
                const label = document.createElement("label");
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.checked = true;

                // Checkbox click event to add or remove the layer from the map
                checkbox.onclick = () => {
                    checkbox.checked ? map.addLayer(layer) : map.removeLayer(layer);
                };

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(" " + fileName));
                checkboxContainer.appendChild(label);
                checkboxContainer.appendChild(document.createElement("br"));
            }

            // Event handler for loaded files
            control.loader.on('data:loaded', function(event) {
                const layer = event.layer;
                uploadedLayers.push(layer);
            
                const fileName = event.filename || "Uploaded Layer " + uploadedLayers.length;
                const color = getRandomColor(); // Generate a color for the layer
            
                // Style the uploaded layer with the random color
                layer.setStyle({
                    color: color,
                    weight: 2
                });
            
                // Add the uploaded layer to the map
                map.addLayer(layer);
            
                // Create a checkbox for toggling the layer
                createCheckboxForAddedLayer(layer, fileName);
            
                // Add the uploaded layer to the legend
                updateLegend(fileName, color, 1, "add");
            });
            
            // Function to generate the WFS query URL
            function wfsQuery(dataset, query = null, fields = [], startIndex = 0, count = 5000 ) {
                const SERVICE_URL = "http://localhost:5000/wfs";
            
                const params = new URLSearchParams({
                    service: 'WFS',
                    version: '2.0.0',
                    request: 'GetFeature',
                    typeName: `pub:${dataset}`,
                    outputFormat: 'application/json',
                    srsName: 'EPSG:4326',
                    bbox: [54.94267775412879, -130.02081515748938, 56.60674270353342, -127.66422698319626, 'urn:ogc:def:crs:EPSG:4326'].join(','),
                    sortBy: 'OBJECTID',
                    startIndex: startIndex,
                    count: count

                });
            
                // Use INTERSECTS filter with a POLYGON if bbox is provided
            
                if (query) {
                    params.delete('bbox');
                    if (params.has('CQL_FILTER')) {
                        params.set('CQL_FILTER', `${params.get('CQL_FILTER')} AND ${query}`);
                    } else {
                        params.set('CQL_FILTER', query);
                    }
                }
            
                if (fields && fields.length > 0) {
                    params.append('propertyName', fields.map(field => field.toUpperCase()).join(','));
                }
            
                if (count !== null) {
                    params.append('count', count);
                }
            
                const url = `${SERVICE_URL}${params.toString()}`;
                console.log("WFS URL:", url);
                return url;
            }

            // store active layers as an object keyed by layer name
            var activeLayers = {};



            // Fetch the WFS data and add it as a GeoJSON layer
            async function loadWFSData(dataset, query, fields, popupFields, color) {
                const count = 5000; // Limit of features per request
                let startIndex = 0; // Starting index for pagination
                let hasMoreData = true; // Flag to track if more data is available
            
                const groupLayer = L.featureGroup();
            
                while (hasMoreData) {
                    const url = wfsQuery(dataset, query, fields, startIndex, count);
            
                    try {
                        const response = await fetch(url);
                        if (!response.ok) {
                            console.error(`Error: ${response.statusText}`);
                            break;
                        }
            
                        const data = await response.json();
                        if (data.features && data.features.length > 0) {
                            const geoJsonLayer = L.geoJSON(data, {
                                style: {
                                    color: color,
                                    weight: 2,
                                    opacity: 0.8 // Matches the legend transparency
                                },
                                onEachFeature: function (feature, layer) {
                                    let popupContent = "";
                                    popupFields.forEach(field => {
                                        if (feature.properties[field]) {
                                            popupContent += `<strong>${field}:</strong> ${feature.properties[field]}<br>`;
                                        }
                                    });
                                    if (popupContent) {
                                        layer.bindPopup(popupContent);
                                    }
                                }
                            });
            
                            groupLayer.addLayer(geoJsonLayer);
                            map.addLayer(groupLayer);
            
                            startIndex += count;
            
                            if (data.features.length < count) {
                                hasMoreData = false; // No more data
                            }
                        } else {
                            hasMoreData = false; // Stop if no features
                        }
                    } catch (error) {
                        console.error('Error fetching WFS data:', error);
                        break;
                    }
                }
            
                return groupLayer;
            }

            // Function to generate random color for styling layers
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            function updateLegend(layerName, color, transparency, action) {
                const legendContent = document.getElementById("legendContent");
                const id = `legend-${layerName}`;
            
                if (action === "add") {
                    if (document.getElementById(id)) return;
            
                    const legendItem = document.createElement("div");
                    legendItem.id = id;
                    legendItem.style.display = "flex";
                    legendItem.style.alignItems = "center";
                    legendItem.style.marginBottom = "5px";
            
                    const colorPatch = document.createElement("span");
                    colorPatch.style.width = "20px";
                    colorPatch.style.height = "20px";
                    colorPatch.style.backgroundColor = color;
                    colorPatch.style.opacity = transparency;
                    colorPatch.style.border = "1px solid #000";
                    colorPatch.style.marginRight = "10px";
            
                    const layerLabel = document.createElement("span");
                    layerLabel.textContent = layerName;
            
                    legendItem.appendChild(colorPatch);
                    legendItem.appendChild(layerLabel);
            
                    legendContent.appendChild(legendItem);
                } else if (action === "remove") {
                    const legendItem = document.getElementById(id);
                    if (legendItem) legendContent.removeChild(legendItem);
                }
            }
            
            // Toggle layer function updated to pass Popup and Color
            async function layerToggleWFS(checkbox, index) {
                const layerData = jsonData[index];
                const layerName = layerData.name;
                const dataset = layerData.dataset;
                const query = layerData.query;
                const sanitizeJSON = (str) => str.replace(/,(\s*[\]}])/g, '$1');
                const fields = JSON.parse(sanitizeJSON(layerData.fields.replace(/'/g, '"')));
                const popupFields = JSON.parse(sanitizeJSON(layerData.popup.replace(/'/g, '"')));
                const color = layerData.color;
                const transparency = 0.5;
            
                if (checkbox.checked) {
                    if (!activeLayers[dataset]) {
                        const groupLayer = await loadWFSData(dataset, query, fields, popupFields, color);
                        activeLayers[dataset] = groupLayer; // Store the group layer
                        updateLegend(layerName, color, transparency, "add");
                    }
                } else {
                    if (activeLayers[dataset]) {
                        map.removeLayer(activeLayers[dataset]); // Remove the group layer
                        delete activeLayers[dataset];
                        updateLegend(layerName, color, transparency, "remove");
                    }
                }
            }

        </script>
    </div>

    <!-- Intersected Data Section -->
    <div class="data-section">
        {% if intersected_data_1 %}
            <h3>Legal Planning Objective Polygons</h3>
            <button class="minimize-btn" onclick="toggleTableVisibility('intersected-data-1')">Minimize</button>
            <div id="intersected-data-1" class="table-container">
                <table id="intersected-data-1-table">
                    <thead>
                        <tr>
                            <th>Legal Feature ID</th>
                            <th>Plan Name</th>
                            <th>Objective</th>
                            <th>Legalization Date</th>
                            <th>Document Title</th>
                            <th>Document URL</th>
                            <th>Metadata Link</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for row in intersected_data_1 %}
                            <tr>
                                <td>{{ row['LEGAL_FEAT_ID'] }}</td>
                                <td>{{ row['STRGC_LAND_RSRCE_PLAN_NAME'] }}</td>
                                <td>{{ row['LEGAL_FEAT_OBJECTIVE'] }}</td>
                                <td>{{ row['LEGALIZATION_DATE'] }}</td>
                                <td>{{ row['ENABLING_DOCUMENT_TITLE'] }}</td>
                                <td><a href="{{ row['ENABLING_DOCUMENT_URL'] }}" target="_blank">Link</a></td>
                                <td><a href="{{ row['RSRCE_PLAN_METADATA_LINK'] }}" target="_blank">Link</a></td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% else %}
            <p>No Legal Planning Objective Polygon data found</p>
        {% endif %}

        {% if intersected_data_2 %}
            <h3>Non-Legal Planning Objective Polygons</h3>
            <button class="minimize-btn" onclick="toggleTableVisibility('intersected-data-2')">Minimize</button>
            <div id="intersected-data-2" class="table-container">
                <table id="intersected-data-2-table">
                    <thead>
                        <tr>
                            <th>Non Legal Feature ID</th>
                            <th>Plan Name</th>
                            <th>Objective</th>
                            <th>Decision Date</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for row in intersected_data_2 %}
                            <tr>
                                <td>{{ row['NON_LEGAL_FEAT_ID'] }}</td>
                                <td>{{ row['STRGC_LAND_RSRCE_PLAN_NAME'] }}</td>
                                <td>{{ row['NON_LEGAL_FEAT_OBJECTIVE'] }}</td>
                                <td>{{ row['ORIGINAL_DECISION_DATE'] }}</td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% else %}
            <p>No Non-Legal Planning Objective Polygon data found</p>
        {% endif %}
    </div>

    {% if not intersected_data_1 and not intersected_data_2 %}
        <p>No Data - Upload a file and intersect.</p>
    {% endif %}

    <!-- Add these two buttons to download separate CSVs -->
    {% if intersected_data_1 %}
        <button class="download-btn" onclick="downloadTableAsCSV('intersected-data-1-table', 'legal_data.csv')">Download Legal Planning CSV</button>
    {% endif %}
    {% if intersected_data_2 %}
        <button class="download-btn" onclick="downloadTableAsCSV('intersected-data-2-table', 'non_legal_data.csv')">Download Non-Legal Planning CSV</button>
    {% endif %}

    <script>
        // JavaScript to toggle the visibility of the tables
        function toggleTableVisibility(tableId) {
            const tableContainer = document.getElementById(tableId);
            if (tableContainer.style.display === "none") {
                tableContainer.style.display = "block";
            } else {
                tableContainer.style.display = "none";
            }
        }

        function downloadTableAsCSV(tableId, filename) {
            const table = document.getElementById(tableId);
            let csv = [];
            
            // Get the table headers
            const headers = [];
            const headerRow = table.querySelectorAll('th');
            headerRow.forEach(header => {
                headers.push(header.innerText);
            });
            csv.push(headers.join(',')); // Join headers as the first row
        
            // Get the table rows
            const rows = table.querySelectorAll('tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length > 0) {
                    let rowData = [];
                    cells.forEach(cell => {
                        rowData.push(cell.innerText);
                    });
                    csv.push(rowData.join(',')); // Join cells for each row
                }
            });
        
            // Create CSV file and trigger download
            const csvString = csv.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename); // Use the provided filename
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    </script>
</body>
</html>
